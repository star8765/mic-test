<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Mic Visual</title>
    <link rel="manifest" href="manifest.json" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
      }
      #fullscreen {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: black;
      }
      #startBtn {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 1em 2em;
        font-size: 20px;
        background: white;
        border: none;
        border-radius: 8px;
        z-index: 100;
      }
      #micSelect {
        position: absolute;
        top: 20px;
        right: 10px;
        z-index: 99;
        font-size: 16px;
      }
      #palette {
        position: absolute;
        top: 30px;
        left: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        z-index: 99;
      }
      .colorBtn {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: 2px solid white;
        outline: none;
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      .colorBtn.selected {
        border: 3px solid white;
        transform: scale(1.3);
      }
      .fs-button,
      .fs-exit-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 60px;
        height: 60px;
        border: none;
        border-radius: 30px;
        background-color: rgba(255, 255, 255, 0.9);
        color: black;
        font-size: 24px;
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        z-index: 1000;
        transition: opacity 0.5s ease;
      }
      .fs-exit-button {
        display: none;
      }
      #memo {
        position: absolute;
        top: 80px;
        left: 10px;
        color: white;
        font-size: 14px;
        background: transparent;
        z-index: 99;
      }
    </style>
  </head>
  <body>
    <select id="micSelect"></select>
    <button id="startBtn">Tap to Start Mic</button>
    <div id="palette"></div>
    <div id="memo">更新メモ：7/31 外部マイク選択対応</div>
    <button class="fs-button" onclick="enterFullScreen()">
      <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
    </button>
    <button class="fs-exit-button" onclick="exitFullScreen()">
      <i class="fa-solid fa-down-left-and-up-right-to-center"></i>
    </button>
    <script>
      const colorOptions = [
        "#FFD93D",
        "#3ABEFF",
        "#A3F948",
        "#FF7CA3",
        "#B067D1",
        "#2EC27E",
        "#FF914D",
        "#FFFFFF",
      ];
      let selectedColor = colorOptions[0];
      const startBtn = document.getElementById("startBtn");
      const palette = document.getElementById("palette");
      const micSelect = document.getElementById("micSelect");
      let audioContext,
        analyser,
        micSource,
        dataArray,
        smoothRMS = 0;
      let wakeLock = null;

      async function enterFullScreen() {
        const element = document.documentElement;
        if (element.requestFullscreen) await element.requestFullscreen();
        else if (element.webkitRequestFullscreen)
          await element.webkitRequestFullscreen();
        document.querySelector(".fs-button").style.display = "none";
        document.querySelector(".fs-exit-button").style.display = "flex";
        try {
          if ("wakeLock" in navigator)
            wakeLock = await navigator.wakeLock.request("screen");
        } catch (err) {
          console.error("Wake Lock エラー:", err);
        }
      }

      async function exitFullScreen() {
        if (document.exitFullscreen) await document.exitFullscreen();
        else if (document.webkitExitFullscreen)
          await document.webkitExitFullscreen();
        document.querySelector(".fs-exit-button").style.display = "none";
        document.querySelector(".fs-button").style.display = "flex";
        if (wakeLock !== null) {
          try {
            await wakeLock.release();
            wakeLock = null;
          } catch (err) {
            console.error("Wake Lock 解放エラー:", err);
          }
        }
      }

      colorOptions.forEach((color) => {
        const btn = document.createElement("button");
        btn.className = "colorBtn";
        btn.style.backgroundColor = color;
        btn.setAttribute("data-color", color);
        btn.onclick = () => {
          selectedColor = color;
          updatePalette();
        };
        palette.appendChild(btn);
      });

      function updatePalette() {
        document.querySelectorAll(".colorBtn").forEach((btn) => {
          btn.classList.toggle(
            "selected",
            btn.getAttribute("data-color") === selectedColor
          );
        });
      }
      updatePalette();

      async function updateMicSelectOptions() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(
          (device) => device.kind === "audioinput"
        );
        micSelect.innerHTML = "";
        audioInputs.forEach((device) => {
          const option = document.createElement("option");
          option.value = device.deviceId;
          option.textContent =
            device.label || `マイク (${micSelect.length + 1})`;
          micSelect.appendChild(option);
        });
      }

      startBtn.addEventListener("click", async () => {
        startBtn.style.display = "none";
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        try {
          await navigator.mediaDevices.getUserMedia({ audio: true });
          await updateMicSelectOptions();
          const selectedId = micSelect.value;
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: { deviceId: selectedId ? { exact: selectedId } : undefined },
          });
          micSource = audioContext.createMediaStreamSource(stream);
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048;
          micSource.connect(analyser);
          dataArray = new Uint8Array(analyser.fftSize);
          animate();
        } catch (err) {
          alert("マイク取得に失敗しました: " + err.message);
        }
      });

      function animate() {
        requestAnimationFrame(animate);
        analyser.getByteTimeDomainData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          let val = dataArray[i] - 128;
          sum += val * val;
        }
        let rms = Math.sqrt(sum / dataArray.length);
        if (rms > smoothRMS) smoothRMS = rms;
        else smoothRMS = smoothRMS * 0.9 + rms * 0.1;

        const GAIN_MULTIPLIER = 20;
        const BASE_BLEND = 0.1;
        const MAX_BLEND_RANGE = 0.9;
        let brightness = Math.min(1, (smoothRMS * GAIN_MULTIPLIER) / 128);
        let blend = BASE_BLEND + brightness * MAX_BLEND_RANGE;
        blend = Math.min(1, blend);

        const target = hexToRgb(selectedColor);
        const base = { r: 55, g: 55, b: 55 };
        const lerpColor = {
          r: Math.round(base.r + (target.r - base.r) * blend),
          g: Math.round(base.g + (target.g - base.g) * blend),
          b: Math.round(base.b + (target.b - base.b) * blend),
        };
        document.body.style.backgroundColor = `rgb(${lerpColor.r}, ${lerpColor.g}, ${lerpColor.b})`;
      }

      function hexToRgb(hex) {
        return {
          r: parseInt(hex.slice(1, 3), 16),
          g: parseInt(hex.slice(3, 5), 16),
          b: parseInt(hex.slice(5, 7), 16),
        };
      }

      if ("serviceWorker" in navigator) {
        navigator.serviceWorker
          .register("service-worker.js")
          .then(() => console.log("Service Worker 登録完了"))
          .catch((err) => console.error("Service Worker 登録失敗:", err));
      }
    </script>
  </body>
</html>
